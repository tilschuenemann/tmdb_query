
# setup -------------------------------------------------------------------

# check if packages are installed and load
packages = c("httr", "jsonlite",
             "dplyr", "tidyr","stringr",
             "tcltk")

package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

# open dialog for setting wd
# using tcltk as other options differ by os
setwd(tclvalue(tkchooseDirectory()))

# check for config
if(file.exists("tmdb_query_config.csv")==T){
  api_key <- read.csv2("tmdb_query_config.csv")[,2]
  } else {
  print("no existing config found")
  
  tmdb_query_config <- as.data.frame("api_key")
  names(tmdb_query_config) <- "generated by tmdb_query"
  tmdb_query_config$value <- NA
  
  write.csv2(tmdb_query_config, "tmdb_query_config.csv", row.names = F)
  
  # TODO possible minor issue: os-specific dir separator 
  config_fp <- paste0("created ",getwd(),"/tmdb_query_config.csv")
  print(config_fp)
  }

if(str_length(api_key)!=32){
  print("the provided api_key seems to be incorrect")
  stop()
}

# check and read existing cache -------------------------------------------

existing_cache <- "tmdb_db.csv"

if(file.exists(existing_cache)==T){
  
  # TODO rename
  # read cache and filter NA
  existing_cache2 <- read.csv2(existing_cache)
  
  existing_cache2 <- existing_cache2 %>%
    filter(tmdb_title %in% NA) %>%
    select(cache_dirname, cache_title)
  
  names(existing_cache2) <- c("cache_dir","cache_title")
  
} else {
  print("no existing cache found in this working directory")
  print("building a new one")
}

# directories to title and year df ----------------------------------------

# get directories with path
dir <- as.data.frame(list.dirs(full.names = F,recursive = F))
dir_path <- as.data.frame(list.dirs(recursive = F))
movie_list <- cbind(dir,dir_path)
names(movie_list)<-c("cache_dir","cache_dirpath")

# TODO create diff with missing entries, changed dir names
# right_join(movie_list, existing_cache2, by="cache_dir")

# my movies go like this: moviename (year) (subtitles)
movie_list <- movie_list %>%
  mutate(w1 = word(cache_dir,-1), # extracting word by word, 
         w2 = word(cache_dir,-2), # there is probably a regex for this
         toBeRemoved = str_length(paste0(w1,w2))+2, 
         cache_title = substr(cache_dir,0, str_length(cache_dir)-toBeRemoved), # get title
         cache_year = as.numeric(gsub("\\(|\\)","",w2)),
         cache_audsub = gsub("\\(|\\)","",w1)) %>%
  select(-w1,-w2,-toBeRemoved) %>%
  mutate(cache_urltitle = gsub("[ ]", "+", cache_title)) # prepare for url

# add directory list as col
movie_list <- cbind(movie_list,dir_list)

remove(dir_list)

# querying tmdb api -------------------------------------------------------

tmdb_list <- NULL
movies_not_found <- NULL
j <- nrow(movie_list)

for (i in 1:j) {

  # query with title and year of movie
  title = movie_list$cache_urltitle[i]
  year = movie_list$cache_year[i]
  url1 = paste0("https://api.themoviedb.org/3/search/movie?api_key=",api_key,"&query=",title,"&year=",year)
  url2 = paste0("https://api.themoviedb.org/3/search/movie?api_key=",api_key,"&query=",title)
  
  unpack_query <- function(url_arg){
    
    res = GET(url_arg)
    
    
    res = GET(url1)
    
    # convert from raw characters to json to dataframe
    single_call <- res$content %>%
      rawToChar() %>%
      fromJSON()
    
    single_call<-unlist(single_call[2],recursive = F, use.names = T) %>%
      do.call(cbind,.) %>%
      as.data.frame()
    
    # change header prefix
    names(single_call) <- str_replace(names(single_call), pattern = "results.", replacement = "tmdb_")
    
    return(single_call)
  } 
  
  single_call <- unpack_query(url1)
  
  # check without year if there are no results
  if(nrow(single_call)==0){
    single_call <- unpack_query(url2)
  }
  
  # get case for pushing result to final list
  n <- nrow(single_call)
 
  if(n==0 | is.null(n)){
    print(paste0("No results found for: ",movie_list$cache_title[i],", year: ",year, ", id: ",i))
    
    movies_not_found <- rbind(movie_list[i,c("cache_dirpath", "cache_title")],movies_not_found)
    next
    
  } else if(n>= 1){
    
    # get most popular if there are more results
    if(n > 1){
      single_call <- single_call %>%
        slice(which.max(tmdb_popularity))
    }
    
    # add references for comparison later
    single_call$cache_title = unlist(movie_list$cache_title[i])
    single_call$cache_dirname = movie_list$cache_dirname[i]
    
    # TODO unnest everything except genre ids
    single_call <-  unnest(single_call,cols = c(names(single_call)))
    
    tmdb_list <- rbind(single_call, tmdb_list)
  } #end if
  
}

remove(n, i, j, url1, url2, title, year)

# write new cache to disk
new_cache <- merge(tmdb_list, movies_not_found, by = c("cache_dirpath", "cache_title"),all = T)
write.csv2(new_cache, "tmdb_db.csv", row.names = F)

